{\rtf1\ansi\ansicpg1252\cocoartf2511
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Nicolas Gundersen (neg62)\
Anthony Tiongson (ast119)\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 CS 352 Project 1\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
The recursive client functionality was implemented using the base project 0 as a starting point.  Both sockets being used are TCP just like in project 0.  The client connects to a user specified RS server hostname that has its IP resolved via socket methods, so it is implied that the RS server is on the same local network as the client (but not necessarily on the same machine).  The client queries the RS server with a hostname meant to trigger the NS response and stores the TS server\'92s hostname information.  This is dramatically different from a real DNS.  The client reads from a list of hostnames line by line and queries each line to the RS server and then waits for a response.  On the RS/TS end, this data is evaluated against a constructed dictionary made from their respective lists of hostnames, IP address, and flags.\
\
The client and the servers behave as the project description outlines.  It was tested successfully on a single macOS system, and then tested on ilabs where client was on a system in ilabs1, rs was on a system on ilabs2, and ts was on a system on ilabs3.  There are no known issues on our end.\
\
Some problems that were faced was general Python semantics since this was the 2nd/3rd project for us written in Python.  Another problem was grappling with the idea that what was being designed is a far cry from what we are taught DNS really is (such as using TCP instead of UDP).  The problem with how to properly handle sockets in terms of when and how to close them and how to multithread the service persists.\
\
Project 1 helped us in understanding TCP socket usage in Python, but more importantly project 0 was very useful in introducing us to these networking concepts in general as well as how to apply them in Python.  I would imagine this project being much more difficult without the starting point and exercises project 0 had.\
\
Although this project doesn\'92t seem to be close to how a real DNS operates, it has become more interesting to think about how to design and implement a real one.}